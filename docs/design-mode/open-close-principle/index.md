# 概述

- **开发扩展，封闭已写好的代码不可修改。**
- 在面向对象的程序设计中，开放封闭原则（OCP）是最重要的一条原则。很多时候，一个程序具有良好的设计，往往说明它是符合开放封闭原则的。
- 软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改。（开放封闭原则最早由 Eiffel 语言的设计者 Bertrand Meyer 在其著作 Object-Oriented SoftwareConstruction 中提出。）

## 扩展 window.onload 函数

- 如果目前的 window.onload 函数是一个拥有 500 行代码的巨型函数，里面密布着各种变量和交叉的业务逻辑，而我们的需求又不仅仅是打印一个 log 这么简单。那么“改好一个 bug，引发其他 bug”这样的事情就很可能会发生。我们永远不知道刚刚的改动会有什么**副作用**，很可能会引发一系列的连锁反应。
- **解决**我们可以采取装饰链after的方式去执行我们新增的函数，让不可改动的函数执行后再去执行after中的函数。`window.onload.after(fn())`，新增的代码和原有的代码可以井水不犯河水。


```js
Function.prototype.after = function( afterfn ){
 var __self = this;
 return function(){
 var ret = __self.apply( this, arguments );
 afterfn.apply( this, arguments );
 return ret;
 }
};
window.onload = ( window.onload || function(){} ).after(function(){
 console.log( document.getElementsByTagName( '*' ).length );
}); 
```

## 开放和封闭

- 我们在改动稳定的程序的是否一定要考虑清楚，是否可以用`after()、before()`,这样的函数去处理。避免去改源程序，若真要改源程序考虑是否可以用更加简单优雅的方式去处理。类似于电风扇吹空的包装盒。

## 用对象的多态性消除条件分支

- 实际上，每当我们看到一大片的 if 或者 swtich-case 语句时，第一时间就应该考虑，能否利用对象的多态性来重构它们。
  
```js
    function Dog(){}
    Dog.prototype.sound=function(){
        console.log('dog sound')
    }
    function Cat(){}
    Cat.prototype.sound=function(){
        console.log('cat sound')
    }

    function mankSound(animal){
        animal.sound()
    }

    mankSound(new Dog())
    mankSound(new Cat())
```

## 找出变化的地方

- 通过封装变化的方式，可以把系统中稳定不变的部分和容易变化的部分隔离开来。在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经被封装好的，那么替换起来也相对容易。而变化部分之外的就是稳定的部分。在系统的演变过程中，稳定的部分是不需要改变的。
- 1. 放置挂钩
  - 放置挂钩（hook）也是分离变化的一种方式。我们在程序有可能发生变化的地方放置一个挂钩，挂钩的返回结果决定了程序的下一步走向。这样一来，原本的代码执行路径上就出现了一个分叉路口，程序未来的执行方向被预埋下多种可能性。
- 2. 使用回调函数
  - 回调函数是一种特殊的挂钩。我们可以把一部分易于变化的逻辑封装在回调函数里，然后把回调函数当作参数传入一个稳定和封闭的函数中。当回调函数被执行的时候，程序就可以因为回调函数的内部逻辑不同，而产生不同的结果。
  
## 设计模式中的开放－封闭原则

- 1. 发布订阅模式
- 2. 模板方法模式
- 3. 策略模式
- 4. 代理模式
- 5. 职责链模式

## 开放－封闭原则的相对性

- 挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化。
- 在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。拿一个开源库来说，修改它提供的配置文件，总比修改它的源代码来得简单。 

## 接受第一次愚弄

- 愚弄我一次，应该羞愧的是你。再次愚弄我，应该羞愧的是我。
- 让程序一开始就尽量遵守开放封闭原则，并不是一件很容易的事情。一方面，我们需要尽快知道程序在哪些地方会发生变化，这要求我们有一些“未卜先知”的能力。另一方面，留给程序员的需求排期并不是无限的，所以我们可以说服自己去接受不合理的代码带来的第一次愚弄。
  