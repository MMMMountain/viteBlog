# 概述

- 最少知识原则（LKP）说的是一个软件实体应当尽可能少地与其他实体发生相互作用。

## 减少对象之间的联系

- 某军队中的将军需要挖掘一些散兵坑。下面是完成任务的一种方式：将军可以通知上校让他叫来少校，然后让少校找来上尉，并让上尉通知一个军士，最后军士唤来一个士兵，然后命令士兵挖掘一些散兵坑。这种方式十分荒谬，不是吗？不过，我们还是先来看一下这个过程的等价代码：gerneral.getColonel( c ).getMajor( m ).getCaptain( c ) .getSergeant( s ).getPrivate( p ).digFoxhole();让代码通过这么长的消息链才能完成一个任务，这就像让将军通过那么多繁琐的步骤才能命
- 最少知识原则要求我们在设计程序时，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对象，来承担这些对象之间的通信作用。令别人挖掘散兵坑一样荒谬！而且，这条链中任何一个对象的改动都会影响整条链的结果。

## 设计模式中的最少知识原则

- 中介者模式
  - 在世界杯期间购买足球彩票，如果没有博彩公司作为中介，上千万的人一起计算赔率和输赢绝对是不可能的事情。博彩公司作为中介，每个人都只和博彩公司发生关联，博彩公司会根据所有人的投注情况计算好赔率，彩民们赢了钱就从博彩公司拿，输了钱就赔给博彩公司。中介者模式很好地体现了最少知识原则。通过增加一个中介者对象，让所有的相关对象都通过中介者对象来通信，而不是互相引用。所以，当一个对象发生改变时，只需要通知中介者对象即可。

- 外观模式
  - 一个函数包含一些子子函数的集合。类似于洗衣机的功能，有漂洗、自清洁、脱水、毛衣洗涤，这些提供的功能都是一些子函数的集合。列如，`cleanSweater(water(10),shampoo(1000),cleanTime(20),speed(3000))`,一组函数的集合。简化了用户的操作，我们的函数操作也一致。
  - 为一组子系统提供一个简单便利的访问入口。
  - 隔离客户与复杂子系统之间的联系，客户不用去了解子系统的细节。

## 封装在最少知识原则中的体现

- 把变量的可见性限制在一个尽可能小的范围内，这个变量对其他不相关模块的影响就越小，变量被改写和发生冲突的机会也越小。这也是广义的最少知识原则的一种体现。
- 手写一个有缓存的乘积
  
```js
    const mul=function(){
        let cache={}
        return function(){
           const argumentsArr=Array.from(arguments)
           const key=argumentsArr.toString()
            if(cache[key]){
               console.log('cache')
                return cache[key]
            }
            return cache[key]=argumentsArr.reduce((total,item)=>total*item,1)
        }
    }
    const myMul=mul()
    console.log(myMul(3,2,1))
    console.log(myMul(3,2,1))
```
